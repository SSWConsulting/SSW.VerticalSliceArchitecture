# FastEndpoints Implementation for Heroes Feature

This document explains the FastEndpoints implementation alongside the existing Minimal API endpoints.

## Overview

The Heroes feature now supports both:
1. **Minimal API endpoints** (existing) - `CreateHeroCommand`, `UpdateHeroCommand`, `GetAllHeroesQuery`
2. **FastEndpoints** (new) - `CreateHeroFastEndpoint`, `UpdateHeroFastEndpoint`, `GetAllHeroesFastEndpoint`

Both implementations work side-by-side and share the same domain logic, database context, and validation rules.

## FastEndpoints Structure

### Endpoints

- **GetAllHeroesFastEndpoint** - `GET /api/heroes` - Retrieves all heroes
- **CreateHeroFastEndpoint** - `POST /api/heroes` - Creates a new hero
- **UpdateHeroFastEndpoint** - `PUT /api/heroes/{heroId}` - Updates an existing hero

### Key Components

#### 1. Endpoint Base Classes
Located in `/Common/FastEndpoints/EndpointBase.cs`, provides:
- ErrorOr result handling
- Consistent error response formatting
- Base functionality for all endpoints

#### 2. Pre/Post Processors
These replace MediatR behaviors for FastEndpoints:

- **LoggingPreProcessor** - Logs incoming requests (equivalent to `LoggingBehaviour`)
- **PerformancePreProcessor/PostProcessor** - Tracks and logs slow requests (equivalent to `PerformanceBehaviour`)
- **UnhandledExceptionHandler** - Global exception handling (equivalent to `UnhandledExceptionBehaviour`)

#### 3. Validation
FastEndpoints uses the same FluentValidation validators as the Minimal API:
- `Validator<Request>` classes in each endpoint
- Automatic validation before handler execution
- ErrorOr integration for consistent error responses

#### 4. Event Handling

**Event Publishing:**
- FastEndpoints endpoints queue domain events using `IFastEndpointEventPublisher`
- Events are stored in `HttpContext.Items` for eventual consistency
- `EventualConsistencyMiddleware` publishes events to both MediatR and FastEndpoints event bus after response is sent

**Event Handlers:**
- `PowerLevelUpdatedFastEventHandler` - FastEndpoints event handler for `PowerLevelUpdatedEvent`
- Handles the same logic as the MediatR version but uses FastEndpoints event model

## Behaviors Mapping

| MediatR Behavior | FastEndpoints Equivalent | Location |
|-----------------|-------------------------|----------|
| LoggingBehaviour | LoggingPreProcessor | Common/FastEndpoints/LoggingPreProcessor.cs |
| PerformanceBehaviour | PerformancePreProcessor + PerformancePostProcessor | Common/FastEndpoints/Performance*.cs |
| UnhandledExceptionBehaviour | GlobalExceptionHandler | Common/FastEndpoints/UnhandledExceptionHandler.cs |
| ValidationErrorOrResultBehavior | Built-in validation + ErrorOr support | Common/FastEndpoints/EndpointBase.cs |

## Event Flow

### For FastEndpoints:
1. Endpoint handler executes business logic
2. Domain events are generated by aggregate root
3. Events are queued via `IFastEndpointEventPublisher.QueueDomainEvent()`
4. Response is sent to client
5. `EventualConsistencyMiddleware` publishes queued events to both:
   - MediatR (for existing MediatR handlers)
   - FastEndpoints event bus (for FastEndpoints event handlers)
6. Event handlers process the events asynchronously

### For Minimal APIs (unchanged):
1. Endpoint handler sends command/query to MediatR
2. MediatR handler executes business logic
3. Domain events are generated by aggregate root
4. `DispatchDomainEventsInterceptor` queues events during SaveChanges
5. Response is sent to client
6. `EventualConsistencyMiddleware` publishes queued events

## Configuration

### Program.cs
```csharp
// Add FastEndpoints
services.AddFastEndpoints(options =>
{
    options.Assemblies = [typeof(DependencyInjection).Assembly];
});

// Configure FastEndpoints middleware
app.UseFastEndpoints(config =>
{
    config.Endpoints.RoutePrefix = "api";
    config.Endpoints.Configurator = ep =>
    {
        ep.PreProcessor<LoggingPreProcessor<object>>(Order.Before);
        ep.PreProcessor<PerformancePreProcessor<object>>(Order.Before);
        ep.PostProcessor<PerformancePostProcessor<object, object>>(Order.After);
    };
    config.Errors.UseProblemDetails();
});
```

## Testing

Both implementations can be tested using the same integration tests. The endpoints respond with the same data structures and status codes.

Example:
- Minimal API: `POST /api/heroes` (via MediatR)
- FastEndpoints: `POST /api/heroes` (via FastEndpoints)

Note: The route conflict is intentional for demonstration. In production, you would typically use different route prefixes or disable one implementation.

## Advantages of FastEndpoints

1. **Performance** - No reflection-based handler discovery
2. **Type Safety** - Compile-time type checking for routes
3. **Co-location** - Request, validation, and handler in one file
4. **OpenAPI** - Better OpenAPI/Swagger integration
5. **Testing** - Easier to test without MediatR infrastructure

## Migration Strategy

To migrate from Minimal API to FastEndpoints:

1. Create a new `*FastEndpoint.cs` file next to the existing command/query
2. Copy the Request/Response DTOs
3. Move the handler logic to the endpoint's `HandleAsync` method
4. Keep the same validator
5. Use `IFastEndpointEventPublisher` to queue domain events
6. Test both implementations side-by-side
7. Once confident, remove the old Minimal API endpoint

## Notes

- Both implementations share the same `ApplicationDbContext`
- Both use the same FluentValidation validators
- Both use the same domain events and event handlers
- Events are published to both MediatR and FastEndpoints event bus for compatibility
- The existing `DispatchDomainEventsInterceptor` only handles MediatR-based requests
- FastEndpoints requests manually queue events for consistency
